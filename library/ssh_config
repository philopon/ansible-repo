#!/usr/bin/python
import re

class Keyword(object):
    def __init__(self, k, v, comment = None, padding = None, space = None):
        self.key     = k
        self.value   = v
        self.comment = comment
        self.padding = padding
        self.space   = space

    _re = re.compile('^(\s*)(\S+)(\s+)(\S+)')

    def __str__(self):
        return self.key + ' ' + self.value

    def __repr__(self):
        return '<' + str(self) + ':' + str(self.padding) + ':' + str(self.space) + '>'

    @classmethod
    def from_line(cls, line):
        sp = line.split('#')
        comment = '#'.join(sp[1:]) if len(sp) > 1 else None

        s = cls._re.match(sp[0])
        return (cls(s.group(2), s.group(4), comment, len(s.group(1)), len(s.group(3))) if s else None)

    def to_line(self, padding = 0):
        return (' ' * (self.padding or padding)) + self.key + (' ' * (self.space or 1)) + self.value

class Host(Keyword):
    def __init__(self, key, value, comment = None, padding = 0, space = 1):
        Keyword.__init__(self, key, value, comment, padding, space)
        self.__list  = []
        self.n_empty = 0

    _re = re.compile('^(\s*)(host)(\s+)(\S+)', re.IGNORECASE)

    def __str__(self):
        return 'Host ' + self.value + ' ' + repr(self.__list) 

    def __repr__(self):
        return '<' + str(self) + ':' + str(self.padding) + ':' + str(self.space) + ':' + str(self.n_empty) + '>'

    def append(self, elem):
        if type(elem) == str and elem.isspace():
            self.n_empty += 1
        else:
            self.__list += [''] * self.n_empty
            self.n_empty = 0
            self.__list.append(elem)

    def host(self):
        return self.value

    def pretty(self):
        ret = []
        ret.append(' ' * self.padding + self.key + ' ' * self.space + self.value)

        pad = 2
        for e in self.__list:
            if type(e) == Keyword:
                line = e.to_line(pad)
                pad = e.padding or pad
                ret.append(line)
            else:
                ret.append(str(e).strip('\n\r'))
        return "\n".join(ret) + ('\n' * self.n_empty)

    def __getitem__(self, i):
        return self.__list[i]

    def update(self, prm):
        rm  = 0
        mod = 0
        new = []
        counts = {}
        for key in prm.iterkeys():
            counts[key] = 0

        for elem in self.__list:
            if type(elem) != Keyword:
                new.append(elem)
                continue

            hit = False
            for key, value in prm.iteritems():
                if elem.key.lower() == key.lower():
                    hit = True
                    if elem.value != value:
                        mod += 1
                        elem.key   = key
                        elem.value = value
                    new.append(elem)
                else:
                    counts[key] += 1
            if not hit:
                rm += 1

        add = 0
        for key, value in counts.iteritems():
            if value >= len(self.__list):
                add += 1
                new.append(Keyword(key, prm[key]))

        self.__list = new

        return (add,rm,mod)

def group_config_file(file):
    ret = []
    tmp = []
    for line in open(file, 'r'):
        host = Host.from_line(line)
        if type(host) == Host:
            if type(tmp) == list:
                ret = ret + tmp
            else:
                ret.append(tmp)
            tmp = host
        else:
            kw = Keyword.from_line(line)
            if kw:
                tmp.append(kw)
            else:
                tmp.append(line)

    ret.append(tmp)
    return ret

def span_target(spanned, target):
    bf = []
    itr = iter(spanned)
    for host_or_comment in itr:
        if type(host_or_comment) == Host:
            host = host_or_comment
            if host.host() == target:
                af = []
                for a in itr: af.append(a)
                return (bf, host, af)
            else:
                bf.append(host)
        else:
            comment = host_or_comment
            bf.append(comment)
    return (bf, None, [])


def present(module, file, host, params, check):
    if not os.path.isfile(file):
        bf  = []
        tgt = None
        af  = []
    else:
        (bf, tgt, af) = span_target(group_config_file(file), host)

    if tgt:
        c = tgt.update(params)
        m = sum(c)
        if check:
            module.exit_json(changed = m == 0, add = c[0], remove = c[1], modify = c[2])

        if m == 0: 
            module.exit_json(changed = False)
    else:
        tgt = Host("Host", host)
        for key, value in params.iteritems():
            tgt.append(Keyword(key, value, 2, 1))
        tgt.append('\n')

    with open(file, 'w') as f:
        for host in bf + [tgt] + af:
            if type(host) == Host:
                f.write(host.pretty() + '\n')
            else:
                f.write(str(host) + '\n')

    module.exit_json(changed = True)


from ansible.module_utils.basic import *
def main():
    import os
    module = AnsibleModule(
            argument_spec = dict(
                host  = dict(required=True),
                file  = dict(default='~/.ssh/config'),
                state = dict(default='present', choices=['present']),
                ),
            supports_check_mode = True,
            check_invalid_arguments = False
            )

    file  = os.path.expanduser(module.params['file'])
    host  = module.params['host']
    state = module.params['state']
    check = module.check_mode

    params = module.params
    del params['file']
    del params['host']
    del params['state']

    present(module, file, host, params, check)

main()
